#include "UEActivity.h"
#include <vector>
#include <math.h>

using std::string;

///
///_______________________________________________________________________
///
UEActivity::UEActivity()
{
  _leadingLet = new TLorentzVector();

  h_pTChg       = new TH1D*[3];
  h_dN_vs_dphi  = new TH1D*[3];
  h_dpT_vs_dphi = new TH1D*[3];
  h_dN_vs_dphi_A  = new TH1D*[3];
  h_dpT_vs_dphi_A = new TH1D*[3];
  h_NChg        = new TH1D*[3];
  h_pTSChg      = new TH1D*[3];
  char buffer[200];
  for ( unsigned int iregion(0); iregion<3; ++iregion )
    {
      sprintf ( buffer, "h_pTChg[%i]", iregion );
      h_pTChg[iregion] = new TH1D( buffer, buffer, 1000,  0. , 100. );
      
      sprintf ( buffer, "h_dN_vs_dphi[%i]", iregion );
      h_dN_vs_dphi[iregion] = new TH1D( buffer, buffer, 360, -180., 180.);

      sprintf ( buffer, "h_dpT_vs_dphi[%i]", iregion );
      h_dpT_vs_dphi[iregion] = new TH1D( buffer, buffer, 360, -180., 180.);
     
      //new
      sprintf ( buffer, "h_dN_vs_dphi_A[%i]", iregion );
      h_dN_vs_dphi_A[iregion] = new TH1D( buffer, buffer, 360, -180., 180.);

      sprintf ( buffer, "h_dpT_vs_dphi_A[%i]", iregion );
      h_dpT_vs_dphi_A[iregion] = new TH1D( buffer, buffer, 360, -180., 180.);
      
      sprintf( buffer,"N chg[%i]", iregion);
      h_NChg[iregion]= new TH1D( buffer, buffer, 100, 0., 100.);
      sprintf( buffer,"pTS chg[%i]", iregion);
      h_pTSChg[iregion] = new TH1D( buffer, buffer, 1000, 0., 100.);
 
      if(iregion==1)  
	{
	  sprintf ( buffer, "h_dNMax_vs_dphi[%i]", iregion );
	  h_dNMax_vs_dphi= new TH1D( buffer, buffer, 360, -180., 180.);
	  sprintf ( buffer, "h_dNMin_vs_dphi[%i]", iregion );
	  h_dNMin_vs_dphi= new TH1D( buffer, buffer, 360, -180., 180.);
	  sprintf ( buffer, "h_dpTMax_vs_dphi[%i]", iregion );
	  h_dpTMax_vs_dphi= new TH1D( buffer, buffer, 360, -180., 180.);
	  sprintf ( buffer, "h_dpTMin_vs_dphi[%i]", iregion );
	  h_dpTMin_vs_dphi= new TH1D( buffer, buffer, 360, -180., 180.);
	
	}
    }
}


///
///_______________________________________________________________________
///
UEActivityFinder::UEActivityFinder( double theEtaRegion, double thePtThreshold )
{
  etaRegion   = theEtaRegion;
  ptThreshold = thePtThreshold;

  _h_pTChg       = new TH1D*[3];
  _h_dN_vs_dphi  = new TH1D*[3];
  _h_dpT_vs_dphi = new TH1D*[3];
  //new 
  _h_dN_vs_dphi_A  = new TH1D*[3];
  _h_dpT_vs_dphi_A = new TH1D*[3];
  
  _h_NChg        = new TH1D*[3];
  _h_pTSChg      = new TH1D*[3];
 
  _h_dN_vs_dphiN1 = new TH1D[1];
  _h_dN_vs_dphiN2 =new TH1D[1];
  _h_dpT_vs_dphiN1 = new TH1D[1];
  _h_dpT_vs_dphiN2 =new TH1D[1];

  char buffer[200];
  for ( unsigned int iregion(0); iregion<3; ++iregion )
    {
      sprintf ( buffer, "_h_pTChg[%i]", iregion );
      _h_pTChg[iregion] = new TH1D( buffer, buffer, 1000,  0. , 100. );

      sprintf ( buffer, "_h_dN_vs_dphi[%i]", iregion );
      _h_dN_vs_dphi[iregion] = new TH1D( buffer, buffer, 360, -180., 180.);

      sprintf ( buffer, "_h_dpT_vs_dphi[%i]", iregion );
      _h_dpT_vs_dphi[iregion] = new TH1D( buffer, buffer, 360, -180., 180.);
      //new
      sprintf ( buffer, "_h_dN_vs_dphi_A[%i]", iregion );
      _h_dN_vs_dphi_A[iregion] = new TH1D( buffer, buffer, 360, -180., 180.);

      sprintf ( buffer, "_h_dpT_vs_dphi_A[%i]", iregion );
      _h_dpT_vs_dphi_A[iregion] = new TH1D( buffer, buffer, 360, -180., 180.);

      sprintf ( buffer, "_h_NChg[%i]", iregion );
      _h_NChg[iregion] = new TH1D( buffer, buffer, 100,  0. , 100. );
      sprintf ( buffer, "_h_pTSChg[%i]", iregion );
      _h_pTSChg[iregion] = new TH1D( buffer, buffer, 1000,  0. , 100. );

      if(iregion==1)
	{
	  sprintf ( buffer, "_h_dN_vs_dphiN1[%i]", iregion );
	  _h_dN_vs_dphiN1= new TH1D( buffer, buffer, 360, -180., 180.);
	  sprintf ( buffer, "_h_dN_vs_dphiN2[%i]", iregion );
	  _h_dN_vs_dphiN2= new TH1D( buffer, buffer, 360, -180., 180.);
	} 
      if(iregion==1)
      {
	sprintf ( buffer, "_h_dpT_vs_dphiN1[%i]", iregion );
	_h_dpT_vs_dphiN1= new TH1D( buffer, buffer, 360, -180., 180.);
	sprintf ( buffer, "_h_dpT_vs_dphiN2[%i]", iregion );
	_h_dpT_vs_dphiN2= new TH1D( buffer, buffer, 360, -180., 180.);
      } 
    }
}


///
///_______________________________________________________________________
///
Bool_t 
UEActivityFinder::findMC( TClonesArray& Jet, TClonesArray& Particles, UEActivity& theUEActivity)
{
  for ( unsigned int iregion(0); iregion<3; ++iregion )
    {
      _h_pTChg      [iregion]->Reset();
      _h_dN_vs_dphi [iregion]->Reset();
      _h_dpT_vs_dphi[iregion]->Reset();
      //new
      _h_NChg      [iregion]->Reset();
      _h_pTSChg      [iregion]->Reset();
      if(iregion==1)
	{
	  _h_dN_vs_dphiN1->Reset();
	  _h_dN_vs_dphiN2->Reset();
	  _h_dpT_vs_dphiN1->Reset();
	  _h_dpT_vs_dphiN2->Reset();
	} 
   }

  ///
  /// find leading jet in chosen (pT, eta)-range
  ///
  TLorentzVector* leadingJet;
  bool foundLeadingJet( false );
  for(int j=0; j<Jet.GetSize();++j)
    {
      TLorentzVector *v = (TLorentzVector*)Jet.At(j);
      if( TMath::Abs(v->Eta()) <= etaRegion)//lio sul pt del trackjet
	{
	  leadingJet = v;
	  foundLeadingJet = true;
	  break;
	}
    }
  if ( ! foundLeadingJet ) return kFALSE;
  theUEActivity.SetLeadingJet( *leadingJet );
   
  //cout<<"jet"<<endl;
  //cout<<leadingJet->Eta()<<" eta "<<leadingJet->Pt()<<" pT "<<endl; 
  
  ///
  /// fill activity vs dphi
  ///
  for(int i=0;i<Particles.GetSize();++i)
    {
      TLorentzVector *v = (TLorentzVector*)Particles.At(i);
      //cout<<"tracce totali"<<endl;
      //cout<<" pt "<<v->Pt()<<"totali"<<endl;
      //cout<<" eta "<<v->Eta()<<"totali"<<endl;
      double pT ( v->Pt()  );
      if ( pT                   <= ptThreshold ) continue;
      if ( TMath::Abs(v->Eta()) >  etaRegion   ) continue;
      //cout<<"tracce"<<endl;
      //cout<<" pt "<<v->Pt()<<endl;
      double dphi( v->DeltaPhi( *leadingJet ) * 180./TMath::Pi() );

      unsigned int iregion(666);
      if      ( TMath::Abs(dphi) >=   0. && TMath::Abs(dphi) <   60. ) { iregion = 0; } /// towards
      else if ( TMath::Abs(dphi) >=  60. && TMath::Abs(dphi) <  120. ) { iregion = 1; }/// transverse
      else if ( TMath::Abs(dphi) >= 120. && TMath::Abs(dphi) <  180. ) { iregion = 2; }/// away
      else
	{
	  cout << "[UEActivityFinder] Error: dphi = " << dphi << endl;
	  return kFALSE;
	}

      _h_pTChg      [iregion]->Fill(       pT );
      _h_dN_vs_dphi [iregion]->Fill( dphi     );
      _h_dpT_vs_dphi[iregion]->Fill( dphi, pT );
      //Max Min transverse
     
      if ( dphi >=  60. && dphi < 120)   _h_dN_vs_dphiN1->Fill( dphi );
      if ( dphi <= -60. && dphi > -120)  _h_dN_vs_dphiN2->Fill( dphi );
      if ( dphi >=  60. && dphi < 120)   _h_dpT_vs_dphiN1->Fill( dphi,pT );
      if ( dphi <= -60. && dphi > -120)  _h_dpT_vs_dphiN2->Fill( dphi,pT );
    }

  ///
  /// divide histograms by eta-range to get densities
  ///
  double totalEtaRange( 2. * etaRegion );

  for ( unsigned int iregion(0); iregion<3; ++iregion )
    {
      _h_pTChg      [iregion]->Scale( 1./totalEtaRange );
      _h_dN_vs_dphi [iregion]->Scale( 1./totalEtaRange );
      _h_dpT_vs_dphi[iregion]->Scale( 1./totalEtaRange );
     
      
     

      theUEActivity.SetTH1D_pTChg      ( iregion, _h_pTChg[iregion]       );
      theUEActivity.SetTH1D_dN_vs_dphi ( iregion, _h_dN_vs_dphi[iregion]  );
      theUEActivity.SetTH1D_dpT_vs_dphi( iregion, _h_dpT_vs_dphi[iregion] );
      
      //new
      _h_NChg[iregion]->Fill(totalEtaRange*_h_dN_vs_dphi[iregion]->Integral());
      _h_pTSChg[iregion]->Fill(totalEtaRange*_h_dpT_vs_dphi[iregion]->Integral());
      theUEActivity.SetTH1D_NChg        ( iregion, _h_NChg[iregion]       );
      theUEActivity.SetTH1D_pTSChg      ( iregion, _h_pTSChg[iregion]     );

      double N1=0; 
      double N2=0; 
      if(iregion==1)
	{
	  _h_dN_vs_dphiN1->Scale( 1./totalEtaRange );
	  _h_dN_vs_dphiN2->Scale( 1./totalEtaRange );
	  N1 =_h_dN_vs_dphiN1->Integral();       
	  N2 =_h_dN_vs_dphiN2->Integral();       
	  
	  if(N1>N2)
	    {
	      theUEActivity.SetTH1D_dNMax_vs_dphi(_h_dN_vs_dphiN1);
	      theUEActivity.SetTH1D_dNMin_vs_dphi(_h_dN_vs_dphiN2);
	    }
	  else
	    {
	      theUEActivity.SetTH1D_dNMax_vs_dphi(_h_dN_vs_dphiN2);
	      theUEActivity.SetTH1D_dNMin_vs_dphi(_h_dN_vs_dphiN1);
	    }
	  N1=0;
	  N2=0;
	  _h_dpT_vs_dphiN1->Scale( 1./totalEtaRange );
	  _h_dpT_vs_dphiN2->Scale( 1./totalEtaRange );
	  N1 = _h_dpT_vs_dphiN1->Integral();       
	  N2 = _h_dpT_vs_dphiN2->Integral();       
	  //  cout<<N1<<" N1 "<<N2<<" N2 "<<_h_dpT_vs_dphi[iregion]->Integral()<<" all "<<endl;
	  if(N1>N2)
	    {
	      theUEActivity.SetTH1D_dpTMax_vs_dphi(_h_dpT_vs_dphiN1);
	      theUEActivity.SetTH1D_dpTMin_vs_dphi(_h_dpT_vs_dphiN2);
	    }
	  else
	    {
	      theUEActivity.SetTH1D_dpTMax_vs_dphi(_h_dpT_vs_dphiN2);
	      theUEActivity.SetTH1D_dpTMin_vs_dphi(_h_dpT_vs_dphiN1);
	    }
	}
    }

  return kTRUE;
}

///
///_______________________________________________________________________
///

///
///_______________________________________________________________________
///
Bool_t 
UEActivityFinder::findDATA( TClonesArray& Jet, TClonesArray& Particles, UEActivity& theUEActivity ,TrackinJet& prova )
{
  for ( unsigned int iregion(0); iregion<3; ++iregion )
    {
      _h_pTChg      [iregion]->Reset();
      _h_dN_vs_dphi [iregion]->Reset();
      _h_dpT_vs_dphi[iregion]->Reset();
      

      //new
      _h_dN_vs_dphi_A [iregion]->Reset();
      _h_dpT_vs_dphi_A[iregion]->Reset();
      _h_NChg      [iregion]->Reset();
      _h_pTSChg      [iregion]->Reset();
      if(iregion==1)
	{
	  _h_dN_vs_dphiN1->Reset();
	  _h_dN_vs_dphiN2->Reset();
	  _h_dpT_vs_dphiN1->Reset();
	  _h_dpT_vs_dphiN2->Reset();
	} 
   }

  ///
  /// find leading jet in chosen (pT, eta)-range
  ///
  TLorentzVector* leadingJet;
  bool foundLeadingJet( false );
  int indjet=0;
  for(int j=0; j<Jet.GetSize();++j)
    {
      TLorentzVector *v = (TLorentzVector*)Jet.At(j);
      if( TMath::Abs(v->Eta()) <= etaRegion)  //trackjet 
	{
	  leadingJet = v;
	  foundLeadingJet = true;
	  break;
	}
      indjet++;
    }
  if ( ! foundLeadingJet ) return kFALSE;
  theUEActivity.SetLeadingJet( *leadingJet );
 
  // cout<<"jet"<<endl;
  //cout<<leadingJet->Eta()<<" eta "<<leadingJet->Pt()<<" pT "<<endl; 
  //  
  
  ///
  /// fill activity vs dphi
  ///
  for(int i=0;i<Particles.GetSize();++i)
    {
      TLorentzVector *v = (TLorentzVector*)Particles.At(i);
      
      // cout<<"tracce totali"<<endl;
      //cout<<" pt "<<v->Pt()<<"totali"<<endl;
      //cout<<" eta "<<v->Eta()<<"totali"<<endl;
    
      double pT ( v->Pt()  );

      if ( pT                   <= ptThreshold ) continue;
      if ( TMath::Abs(v->Eta()) >  etaRegion   ) continue;
     
      double dphi( v->DeltaPhi( *leadingJet ) * 180./TMath::Pi() );

      unsigned int iregion(666);
      if      ( TMath::Abs(dphi) >=   0. && TMath::Abs(dphi) <   60. ) { iregion = 0;} /// towards
      else if ( TMath::Abs(dphi) >=  60. && TMath::Abs(dphi) <  120. ) { iregion = 1;}/// transverse
      else if ( TMath::Abs(dphi) >= 120. && TMath::Abs(dphi) <  180. ) { iregion = 2;}/// away
      else
	{
	  cout << "[UEActivityFinder] Error: dphi = " << dphi << endl;
	  return kFALSE;
	}
      // cout<<"entrato"<<endl;
      _h_pTChg      [iregion]->Fill(       pT );
      _h_dN_vs_dphi [iregion]->Fill( dphi     );
      _h_dpT_vs_dphi[iregion]->Fill( dphi, pT );
      //Max Min transverse
     
      if ( dphi >=  60. && dphi < 120)   _h_dN_vs_dphiN1->Fill( dphi );
      if ( dphi <= -60. && dphi > -120)  _h_dN_vs_dphiN2->Fill( dphi );
      if ( dphi >=  60. && dphi < 120)   _h_dpT_vs_dphiN1->Fill( dphi,pT );
      if ( dphi <= -60. && dphi > -120)  _h_dpT_vs_dphiN2->Fill( dphi,pT );
    
      ///new sottrazione del jet
      
    
    
    
      //cout<<"traccia sotto esame"<<endl;
      //cout<<" pt "<<v->Pt()<<"  "<<v->Eta()<<endl;
    

      //controllo che la paritcella non appartenga al jet

      //cout<<prova.tkn[indjet]<<"numero tracce jet"<<endl;
      //cout<<indjet<<"indice"<<Jet.GetSize()<<"numero di jet"<<endl;
   
      bool Trackoutofjet=false;
      if(indjet==0)
	{
	  for(int i1=0;i1<prova.tkn[indjet];i1++)
	    {
	      if(fabs(prova.tkpt[i1]-v->Pt())<0.001 && fabs(prova.tketa[i1]-v->Eta())<0.001)
		{
		  Trackoutofjet=true;
		}
	      //      cout<<"Tracce in esame"<<v->Pt()<<" pt "<<v->Eta()<<" eta "<<Trackoutofjet<<endl;
	      //cout<<"Tracce del jet"<<prova.tkpt[i1]<<" pt "<<prova.tketa[i1]<<" eta "<<endl;
	    }
	}
      
      if(indjet>0)
	{
	  
	  int i2=indjet;//qui devo fare la somma dei termini 
	  int i1=0;
	  while(i2)
	    {
	      i2--;
	      i1=i1+prova.tkn[i2];
	      //  cout<<"ciao"<<endl;
	    }
	  int i3 = prova.tkn[indjet]+i1;
	  for(;i1<i3;i1++)
	    {
	      if(fabs(prova.tkpt[i1]-v->Pt())<0.001  && fabs(prova.tketa[i1]-v->Eta())<0.001)
		{
		  Trackoutofjet = true;
		}
	      //cout<<"Tracce in esame"<<v->Pt()<<" pt "<<v->Eta()<<" eta "<<Trackoutofjet<<endl;
	      //cout<<"Tracce del jet"<<prova.tkpt[i1]<<" pt "<<prova.tketa[i1]<<" eta "<<endl;
	    }
	}

            if(!Trackoutofjet)
	{
	  unsigned int iregion(666);
	  if      ( TMath::Abs(dphi) >=   0. && TMath::Abs(dphi) <   60. ) { iregion = 0; } /// towards
	  else if ( TMath::Abs(dphi) >=  60. && TMath::Abs(dphi) <  120. ) { iregion = 1; }/// transverse
	  else if ( TMath::Abs(dphi) >= 120. && TMath::Abs(dphi) <  180. ) { iregion = 2; }/// away
	  else
	    {
	      cout << "[UEActivityFinder] Error: dphi = " << dphi << endl;
	      return kFALSE;
	    }
	  // cout<<"entrato"<<endl;
	  _h_dN_vs_dphi_A[iregion]->Fill( dphi     );
	  _h_dpT_vs_dphi_A[iregion]->Fill( dphi, pT );
	 
	}

    }
  

  ///
  /// divide histograms by eta-range to get densities
  ///
  double totalEtaRange( 2. * etaRegion );

  for ( unsigned int iregion(0); iregion<3; ++iregion )
    {
      _h_pTChg      [iregion]->Scale( 1./totalEtaRange );
      _h_dN_vs_dphi [iregion]->Scale( 1./totalEtaRange );
      _h_dpT_vs_dphi[iregion]->Scale( 1./totalEtaRange );
     
      //new
      _h_dN_vs_dphi_A [iregion]->Scale( 1./totalEtaRange );
      _h_dpT_vs_dphi_A[iregion]->Scale( 1./totalEtaRange );
     

      theUEActivity.SetTH1D_pTChg      ( iregion, _h_pTChg[iregion]       );
      theUEActivity.SetTH1D_dN_vs_dphi ( iregion, _h_dN_vs_dphi[iregion]  );
      theUEActivity.SetTH1D_dpT_vs_dphi( iregion, _h_dpT_vs_dphi[iregion] );
      
      //new
      
      theUEActivity.SetTH1D_dN_vs_dphi_A ( iregion, _h_dN_vs_dphi_A[iregion]  );
      theUEActivity.SetTH1D_dpT_vs_dphi_A( iregion, _h_dpT_vs_dphi_A[iregion] );
      


      _h_NChg[iregion]->Fill(totalEtaRange*_h_dN_vs_dphi[iregion]->Integral());
      _h_pTSChg[iregion]->Fill(totalEtaRange*_h_dpT_vs_dphi[iregion]->Integral());
      theUEActivity.SetTH1D_NChg        ( iregion, _h_NChg[iregion]       );
      theUEActivity.SetTH1D_pTSChg      ( iregion, _h_pTSChg[iregion]     );

      double N1=0; 
      double N2=0; 
      if(iregion==1)
	{
	  _h_dN_vs_dphiN1->Scale( 1./totalEtaRange );
	  _h_dN_vs_dphiN2->Scale( 1./totalEtaRange );
	  N1 =_h_dN_vs_dphiN1->Integral();       
	  N2 =_h_dN_vs_dphiN2->Integral();       
	  
	  if(N1>N2)
	    {
	      theUEActivity.SetTH1D_dNMax_vs_dphi(_h_dN_vs_dphiN1);
	      theUEActivity.SetTH1D_dNMin_vs_dphi(_h_dN_vs_dphiN2);
	    }
	  else
	    {
	      theUEActivity.SetTH1D_dNMax_vs_dphi(_h_dN_vs_dphiN2);
	      theUEActivity.SetTH1D_dNMin_vs_dphi(_h_dN_vs_dphiN1);
	    }
	  N1=0;
	  N2=0;
	  _h_dpT_vs_dphiN1->Scale( 1./totalEtaRange );
	  _h_dpT_vs_dphiN2->Scale( 1./totalEtaRange );
	  N1 = _h_dpT_vs_dphiN1->Integral();       
	  N2 = _h_dpT_vs_dphiN2->Integral();       
	  //  cout<<N1<<" N1 "<<N2<<" N2 "<<_h_dpT_vs_dphi[iregion]->Integral()<<" all "<<endl;
	  if(N1>N2)
	    {
	      theUEActivity.SetTH1D_dpTMax_vs_dphi(_h_dpT_vs_dphiN1);
	      theUEActivity.SetTH1D_dpTMin_vs_dphi(_h_dpT_vs_dphiN2);
	    }
	  else
	    {
	      theUEActivity.SetTH1D_dpTMax_vs_dphi(_h_dpT_vs_dphiN2);
	      theUEActivity.SetTH1D_dpTMin_vs_dphi(_h_dpT_vs_dphiN1);
	    }
	}
    }

  return kTRUE;
}

///
///_______________________________________________________________________
///



UEActivityHistograms::UEActivityHistograms( const char* fileName, string *triggerNames )
{
  ///
  /// Constructor for histogram filler.
  ///

  char buffer[200];

  cout << "[UEActivityHistograms] Create file " << fileName << endl;
  file = TFile::Open( fileName, "recreate" );

  TDirectory*  dir    = file->mkdir( "UEActivity" );
  TDirectory** subdir = new TDirectory*[14];


  ///
  /// Reserve space for histograms.
  ///
  h_pTJet             = new TH1D*[14];
  h_etaJet            = new TH1D*[14];
  h_dN_vs_dphi        = new TH2D*[14];
  h_dpT_vs_dphi       = new TH2D*[14];
  h_averagePt_vs_nChg = new TH2D*[14];
  h_pTSumAll          = new TH1D*[14];
  h_NChgAll           = new TH1D*[14];
  h_pTChg             = new TH2D*[42]; /// one for each region
  h_dN_vs_dpTjet      = new TH2D*[42];
  h_dpT_vs_dpTjet     = new TH2D*[42];
  //new
  h_dN_vs_dphi_A      = new TH2D*[14];
  h_dpT_vs_dphi_A     = new TH2D*[14];
  h_NChg              = new TH1D*[42];
  h_pTSChg            = new TH1D*[42];
  h_pTChg1            = new TH1D*[42]; 
  h_dNMax_vs_dpTjet   = new TH2D*[14];
  h_dNMin_vs_dpTjet   = new TH2D*[14];
  h_dpTMax_vs_dpTjet  = new TH2D*[14];
  h_dpTMin_vs_dpTjet  = new TH2D*[14];

  ///
  /// 12 HLT bits :
  /// 4 Min-Bias (Pixel, Hcal, Ecal, Pixel_Trk5), Zero-Bias, 6 Jet (L115, 30, 80, 110, 140, 180)
  ///
  unsigned int iHLTbit(0);
  for ( ; iHLTbit<12; ++iHLTbit )
    {
      HLTBitNames[iHLTbit] = triggerNames[iHLTbit];

      subdir[iHLTbit] = dir->mkdir( triggerNames[iHLTbit].c_str() );
      sprintf ( buffer, "UEActivity/%s", triggerNames[iHLTbit].c_str() );
      file->cd( buffer );

      ///
      /// Initialize histograms.
      ///
      
      h_pTJet[iHLTbit]
	= new TH1D("h_pTJet",
		   "h_pTJet;p_{T}(jet) (GeV/c);",
		   600, 0., 600. );
      
      h_etaJet[iHLTbit]
	= new TH1D("h_etaJet",
		   "h_etaJet;#eta(jet);",
		   100, -2., 2. );
      
      h_dN_vs_dphi[iHLTbit]
	= new TH2D("h_dN_vs_dphi",
		   "h_dN_vs_dphi;#Delta#phi(charged, jet) (deg);< dN/d#Delta#phid#eta > (1/deg)",
		   360, -180., 180., 1000, 0., 100. );
      h_dpT_vs_dphi[iHLTbit]
	= new TH2D("h_dpT_vs_dphi",
		   "h_dpT_vs_dphi;#Delta#phi(charged, jet) (deg);< d#Sigmap_{T}/d#Delta#phid#eta > (GeV/c / deg)",
		   360, -180., 180., 1000, 0., 100. );

      h_dN_vs_dphi_A[iHLTbit]
	= new TH2D("h_dN_vs_dphi_A",
		   "h_dN_vs_dphi;#Delta#phi(charged, jet) (deg);< dN/d#Delta#phid#eta > (1/deg)",
		   360, -180., 180., 1000, 0., 100. );
      h_dpT_vs_dphi_A[iHLTbit]
	= new TH2D("h_dpT_vs_dphi_A",
		   "h_dpT_vs_dphi;#Delta#phi(charged, jet) (deg);< d#Sigmap_{T}/d#Delta#phid#eta > (GeV/c / deg)",
		   360, -180., 180., 1000, 0., 100. );


      h_averagePt_vs_nChg[iHLTbit]
	= new TH2D("h_averagePt_vs_nChg",
		   "h_averagePt_vs_nChg;;",
		   100, 0.5, 100.5, 200, 0., 20. );
      
      h_NChgAll[iHLTbit]
	= new TH1D("h_NChgAll",
		   "h_NChgAll",
		   100, 0., 100. );

      h_pTSumAll[iHLTbit]
	= new TH1D("h_pTSumAll",
		   "h_pTSumAll",
		   1000, 0., 100. );
      

      string regions[] = { "Towards", "Transverse", "Away" };
      for ( int i(0); i<3; ++i )
	{
	  subdir[iHLTbit]->mkdir( regions[i].c_str() );
	  sprintf ( buffer, "UEActivity/%s/%s", triggerNames[iHLTbit].c_str(), regions[i].c_str() );
	  file->cd( buffer );

	  sprintf ( buffer, "h_pTChg;p_{T}(charged) (GeV/c);%s 1/#sigma d#sigma/dp_{T} (1 / GeV/c)", regions[i].c_str() );
	  h_pTChg[i*13+iHLTbit]
	    = new TH2D("h_pTChg",
		       buffer,
		       1000, 0., 100., 1000, 0., 100. );
	
	  sprintf ( buffer, "h_pTChg;p_{T}(charged) (GeV/c)", regions[i].c_str() );
	  h_pTChg1[i*13+iHLTbit]
	    = new TH1D("h_pTChg1",
		       buffer,
		       1000, 0., 100.);	  

	  sprintf ( buffer, "h_dN_vs_dpTjet;p_{T}(track jet) (GeV/c);%s < dN/d#phid#eta > / 2 GeV/c (1/rad)", regions[i].c_str() );
	  h_dN_vs_dpTjet[i*13+iHLTbit]
	    = new TH2D("h_dN_vs_dpTjet",
		       buffer,
		       600, 0., 600., 1000, 0., 100. );
	  
	  sprintf ( buffer, "h_dpT_vs_dpTjet;p_{T}(track jet) (GeV/c);%s < d#Sigmap_{T}/d#phid#eta > / 2 GeV/c (GeV/c / rad)", regions[i].c_str() );
	  h_dpT_vs_dpTjet[i*13+iHLTbit]
	    = new TH2D("h_dpT_vs_dpTjet",
		       buffer,
		   600, 0., 600., 1000, 0., 100. );
	  //new
	  sprintf( buffer,"N_Chg_%s", regions[i].c_str() );
	  h_NChg[i*13+iHLTbit]= new TH1D( buffer, "N Chg", 100, 0., 100.);
	  sprintf( buffer,"pTSChg_%s", regions[i].c_str() );
	  h_pTSChg[i*13+iHLTbit] = new TH1D( buffer, "pT-Sum 0.1 GeV/c ", 1000, 0., 100.);
	  
	  if(i==1)
	    {
	     sprintf ( buffer, "h_dNMax_vs_dpTjet;p_{T}(track jet) (GeV/c);%s < dN/d#phid#eta > / 2 GeV/c (1/rad)", regions[i].c_str() );
	  h_dNMax_vs_dpTjet[iHLTbit]
	    = new TH2D("h_dNMax_vs_dpTjet",
		       buffer,
		       600, 0., 600., 1000, 0., 100. );
	  sprintf ( buffer, "h_dNMin_vs_dpTjet;p_{T}(track jet) (GeV/c);%s < dN/d#phid#eta > / 2 GeV/c (1/rad)", regions[i].c_str() );
	  h_dNMin_vs_dpTjet[iHLTbit]
	    = new TH2D("h_dNMin_vs_dpTjet",
		       buffer,
		       600, 0., 600., 1000, 0., 100. );

	  sprintf ( buffer, "h_dpTMax_vs_dpTjet;p_{T}(track jet) (GeV/c);%s < dpT/d#phid#eta > / 2 GeV/c (1/rad)", regions[i].c_str() );
	  h_dpTMax_vs_dpTjet[iHLTbit]
	    = new TH2D("h_dpTMax_vs_dpTjet",
		       buffer,
		       600, 0., 600., 1000, 0., 100. );

	  sprintf ( buffer, "h_dpTMin_vs_dpTjet;p_{T}(track jet) (GeV/c);%s < dpT/d#phid#eta > / 2 GeV/c (1/rad)", regions[i].c_str() );
	  h_dpTMin_vs_dpTjet[iHLTbit]
	    = new TH2D("h_dpTMin_vs_dpTjet",
		       buffer,
		       600, 0., 600., 1000, 0., 100. );
	    }
	}
    }


  ///
  /// Hadron level
  ///
  iHLTbit          = 12;
  subdir[iHLTbit] = dir->mkdir( "Gen" );
  file->cd( "UEActivity/Gen" );

  ///
  /// Initialize histograms.
  ///
  h_pTJet[iHLTbit]
    = new TH1D("h_pTJet",
	       "h_pTJet;p_{T}(jet) (GeV/c);",
	       600, 0., 600. );
  
  h_etaJet[iHLTbit]
    = new TH1D("h_etaJet",
	       "h_etaJet;#eta(jet);",
	       100, -2., 2. );
  
  h_dN_vs_dphi[iHLTbit]
    = new TH2D("h_dN_vs_dphi",
	       "h_dN_vs_dphi;#Delta#phi(charged, jet) (deg);< dN/d#Delta#phid#eta > (1/deg)",
	       360, -180., 180., 1000, 0., 100. );
  h_dpT_vs_dphi[iHLTbit]
    = new TH2D("h_dpT_vs_dphi",
	       "h_dpT_vs_dphi;#Delta#phi(charged, jet) (deg);< d#Sigmap_{T}/d#Delta#phid#eta > (GeV/c / deg)",
	       360, -180., 180., 1000, 0., 100. );

  h_dN_vs_dphi_A[iHLTbit]
    = new TH2D("h_dN_vs_dphi_A",
	       "h_dN_vs_dphi;#Delta#phi(charged, jet) (deg);< dN/d#Delta#phid#eta > (1/deg)",
	       360, -180., 180., 1000, 0., 100. );
  h_dpT_vs_dphi_A[iHLTbit]
    = new TH2D("h_dpT_vs_dphi_A",
	       "h_dpT_vs_dphi;#Delta#phi(charged, jet) (deg);< d#Sigmap_{T}/d#Delta#phid#eta > (GeV/c / deg)",
	       360, -180., 180., 1000, 0., 100. );


  h_averagePt_vs_nChg[iHLTbit]
    = new TH2D("h_averagePt_vs_nChg",
	       "h_averagePt_vs_nChg;;",
	       100, 0.5, 100.5, 200, 0., 20. );
  h_NChgAll[iHLTbit]
    = new TH1D("h_NChgAll",
	       "h_NChgAll",
	       100, 0., 100. );

  h_pTSumAll[iHLTbit]
    = new TH1D("h_pTSumAll",
	       "h_pTSumAll",
	       1000, 0., 100. );
  
  string regions[] = { "Towards", "Transverse", "Away" };
  for ( int i(0); i<3; ++i )
    {
      subdir[iHLTbit]->mkdir( regions[i].c_str() );
      sprintf ( buffer, "UEActivity/Gen/%s", regions[i].c_str() );
      file->cd( buffer );

      sprintf ( buffer, "h_pTChg;p_{T}(charged) (GeV/c);%s 1/#sigma d#sigma/dp_{T} (1 / GeV/c)", regions[i].c_str() );
      h_pTChg[i*13+iHLTbit]
	= new TH2D("h_pTChg",
		   buffer,
		   1000, 0., 100., 1000, 0., 100. );
      
      sprintf ( buffer, "h_pTChg;p_{T}(charged) (GeV/c)", regions[i].c_str() );
      h_pTChg1[i*13+iHLTbit]
	= new TH1D("h_pTChg1",
		   buffer,
		   1000, 0., 100.);	      

      sprintf ( buffer, "h_dN_vs_dpTjet;p_{T}(track jet) (GeV/c);%s < dN/d#phid#eta > / 2 GeV/c (1/rad)", regions[i].c_str() );
      h_dN_vs_dpTjet[i*13+iHLTbit]
	= new TH2D("h_dN_vs_dpTjet",
		   buffer,
		   600, 0., 600., 1000, 0., 100. );
      
      sprintf ( buffer, "h_dpT_vs_dpTjet;p_{T}(track jet) (GeV/c);%s < d#Sigmap_{T}/d#phid#eta > / 2 GeV/c (GeV/c / rad)", regions[i].c_str() );
          h_dpT_vs_dpTjet[i*13+iHLTbit]
            = new TH2D("h_dpT_vs_dpTjet",
                       buffer,
		       600, 0., 600., 1000, 0., 100. );
	  //new
	  sprintf( buffer,"NChg_%s", regions[i].c_str() );
	  h_NChg[i*13+iHLTbit]= new TH1D( buffer, "N Chg", 100, 0., 100.);
	  sprintf( buffer,"pTSChg_%s", regions[i].c_str() );
	  h_pTSChg[i*13+iHLTbit] = new TH1D( buffer, "pT-Sum 0.1 GeV/c ", 1000, 0., 100.);

	  if(i==1)
	    {
	      sprintf ( buffer, "h_dNMax_vs_dpTjet;p_{T}(track jet) (GeV/c);%s < dN/d#phid#eta > / 2 GeV/c (1/rad)", regions[i].c_str() );
	      h_dNMax_vs_dpTjet[iHLTbit]
		= new TH2D("h_dNMax_vs_dpTjet",
			   buffer,
			   600, 0., 600., 1000, 0., 100. );
	      sprintf ( buffer, "h_dNMin_vs_dpTjet;p_{T}(track jet) (GeV/c);%s < dN/d#phid#eta > / 2 GeV/c (1/rad)", regions[i].c_str() );
	      h_dNMin_vs_dpTjet[iHLTbit]
		= new TH2D("h_dNMin_vs_dpTjet",
			   buffer,
			   600, 0., 600., 1000, 0., 100. );

	     sprintf ( buffer, "h_dpTMax_vs_dpTjet;p_{T}(track jet) (GeV/c);%s < dpT/d#phid#eta > / 2 GeV/c (1/rad)", regions[i].c_str() );
	      h_dpTMax_vs_dpTjet[iHLTbit]
		= new TH2D("h_dpTMax_vs_dpTjet",
			   buffer,
			   600, 0., 600., 1000, 0., 100. );
	      sprintf ( buffer, "h_dpTMin_vs_dpTjet;p_{T}(track jet) (GeV/c);%s < dpT/d#phid#eta > / 2 GeV/c (1/rad)", regions[i].c_str() );
	      h_dpTMin_vs_dpTjet[iHLTbit]
		= new TH2D("h_dpTMin_vs_dpTjet",
			   buffer,
			   600, 0., 600., 1000, 0., 100. );
	    }
    }

  ///
  ///RECO ---------------------------------------------------------------------------
  ///
  ///
  /// level
  ///

  iHLTbit          = 13;
  subdir[iHLTbit] = dir->mkdir( "Reco" );
  file->cd( "UEActivity/Reco" );

  ///
  /// Initialize histograms.
  ///
  h_pTJet[iHLTbit]
    = new TH1D("h_pTJet",
	       "h_pTJet;p_{T}(jet) (GeV/c);",
	       600, 0., 600. );
  
  h_etaJet[iHLTbit]
    = new TH1D("h_etaJet",
	       "h_etaJet;#eta(jet);",
	       100, -2., 2. );
  
  h_dN_vs_dphi[iHLTbit]
    = new TH2D("h_dN_vs_dphi",
	       "h_dN_vs_dphi;#Delta#phi(charged, jet) (deg);< dN/d#Delta#phid#eta > (1/deg)",
	       360, -180., 180., 1000, 0., 100. );
  h_dpT_vs_dphi[iHLTbit]
    = new TH2D("h_dpT_vs_dphi",
	       "h_dpT_vs_dphi;#Delta#phi(charged, jet) (deg);< d#Sigmap_{T}/d#Delta#phid#eta > (GeV/c / deg)",
	       360, -180., 180., 1000, 0., 100. );

  h_dN_vs_dphi_A[iHLTbit]
    = new TH2D("h_dN_vs_dphi_A",
	       "h_dN_vs_dphi;#Delta#phi(charged, jet) (deg);< dN/d#Delta#phid#eta > (1/deg)",
	       360, -180., 180., 1000, 0., 100. );
  h_dpT_vs_dphi_A[iHLTbit]
    = new TH2D("h_dpT_vs_dphi_A",
	       "h_dpT_vs_dphi;#Delta#phi(charged, jet) (deg);< d#Sigmap_{T}/d#Delta#phid#eta > (GeV/c / deg)",
	       360, -180., 180., 1000, 0., 100. );


  h_averagePt_vs_nChg[iHLTbit]
    = new TH2D("h_averagePt_vs_nChg",
	       "h_averagePt_vs_nChg;;",
	       100, 0.5, 100.5, 200, 0., 20. );
  h_NChgAll[iHLTbit]
    = new TH1D("h_NChgAll",
	       "h_NChgAll",
	       100, 0., 100. );

  h_pTSumAll[iHLTbit]
    = new TH1D("h_pTSumAll",
	       "h_pTSumAll",
	       1000, 0., 100. );
  
  //  string regions[] = { "Towards", "Transverse", "Away" };
  for ( int i(0); i<3; ++i )
    {
      subdir[iHLTbit]->mkdir( regions[i].c_str() );
      sprintf ( buffer, "UEActivity/Reco/%s", regions[i].c_str() );
      file->cd( buffer );

      sprintf ( buffer, "h_pTChg;p_{T}(charged) (GeV/c);%s 1/#sigma d#sigma/dp_{T} (1 / GeV/c)", regions[i].c_str() );
      h_pTChg[i*14+iHLTbit]
	= new TH2D("h_pTChg",
		   buffer,
		   1000, 0., 100., 1000, 0., 100. );

      sprintf ( buffer, "h_pTChg;p_{T}(charged) (GeV/c)", regions[i].c_str() );
      h_pTChg1[i*14+iHLTbit]
	= new TH1D("h_pTChg1",
		   buffer,
		   1000, 0., 100.);	      

      sprintf ( buffer, "h_dN_vs_dpTjet;p_{T}(track jet) (GeV/c);%s < dN/d#phid#eta > / 2 GeV/c (1/rad)", regions[i].c_str() );
      h_dN_vs_dpTjet[i*14+iHLTbit]
	= new TH2D("h_dN_vs_dpTjet",
		   buffer,
		   600, 0., 600., 1000, 0., 100. );
      
      sprintf ( buffer, "h_dpT_vs_dpTjet;p_{T}(track jet) (GeV/c);%s < d#Sigmap_{T}/d#phid#eta > / 2 GeV/c (GeV/c / rad)", regions[i].c_str() );
          h_dpT_vs_dpTjet[i*14+iHLTbit]
            = new TH2D("h_dpT_vs_dpTjet",
                       buffer,
		       600, 0., 600., 1000, 0., 100. );
	  //new

	  sprintf( buffer,"NChg_%s", regions[i].c_str() );
	  h_NChg[i*14+iHLTbit]= new TH1D( buffer, "N Chg", 100, 0., 100.);
	  sprintf( buffer,"pTSChg_%s", regions[i].c_str() );
	  h_pTSChg[i*14+iHLTbit] = new TH1D( buffer, "pT-Sum 0.1 GeV/c ", 1000, 0., 100.);


	  if(i==1)
	    {
	      sprintf ( buffer, "h_dNMax_vs_dpTjet;p_{T}(track jet) (GeV/c);%s < dN/d#phid#eta > / 2 GeV/c (1/rad)", regions[i].c_str() );
	      h_dNMax_vs_dpTjet[iHLTbit]
		= new TH2D("h_dNMax_vs_dpTjet",
			   buffer,
			   600, 0., 600., 1000, 0., 100. );
	      sprintf ( buffer, "h_dNMin_vs_dpTjet;p_{T}(track jet) (GeV/c);%s < dN/d#phid#eta > / 2 GeV/c (1/rad)", regions[i].c_str() );
	      h_dNMin_vs_dpTjet[iHLTbit]
		= new TH2D("h_dNMin_vs_dpTjet",
			   buffer,
			   600, 0., 600., 1000, 0., 100. );

	     sprintf ( buffer, "h_dpTMax_vs_dpTjet;p_{T}(track jet) (GeV/c);%s < dpT/d#phid#eta > / 2 GeV/c (1/rad)", regions[i].c_str() );
	      h_dpTMax_vs_dpTjet[iHLTbit]
		= new TH2D("h_dpTMax_vs_dpTjet",
			   buffer,
			   600, 0., 600., 1000, 0., 100. );
	      sprintf ( buffer, "h_dpTMin_vs_dpTjet;p_{T}(track jet) (GeV/c);%s < dpT/d#phid#eta > / 2 GeV/c (1/rad)", regions[i].c_str() );
	      h_dpTMin_vs_dpTjet[iHLTbit]
		= new TH2D("h_dpTMin_vs_dpTjet",
			   buffer,
			   600, 0., 600., 1000, 0., 100. );
	    }
    }




  //
  //----------------------------------------------------------------------------------------
  //

  ///
  /// save histogram parameters
  ///
  _nbinsDphi    = h_dN_vs_dphi[0]->GetNbinsX();
  _xminDphi     = h_dN_vs_dphi[0]->GetXaxis()->GetXmin();
  _xmaxDphi     = h_dN_vs_dphi[0]->GetXaxis()->GetXmax();
  _binwidthDphi = (_xmaxDphi-_xminDphi)/double(_nbinsDphi);

  _nbinsPtChg    = h_pTChg[0]->GetNbinsX();
  _xminPtChg     = h_pTChg[0]->GetXaxis()->GetXmin();
  _xmaxPtChg     = h_pTChg[0]->GetXaxis()->GetXmax();
  _binwidthPtChg = (_xmaxPtChg-_xminPtChg)/double(_nbinsPtChg);

  //  cout<<"_nbinsDphi"<<_nbinsDphi<<"_binwidthDphi"<<_binwidthDphi<<endl;

}

///
///_______________________________________________________________________
///
void
UEActivityHistograms::fillGen( UEActivity& activity )
{
  ///
  /// histo filler for gen-only analysis
  /// i.e. no trigger bits are available
  ///

  unsigned int iHLTbit( 12 );

  ///
  /// pT-distribution of leading jet
  ///
  double pTjet ( activity.GetLeadingJet().Pt()  );
  double etajet( activity.GetLeadingJet().Eta() );
  h_pTJet [iHLTbit]->Fill( pTjet  );
  h_etaJet[iHLTbit]->Fill( etajet );
  //cout<<"jet nella parte fill"<<endl;
  //cout<<etajet<<" eta "<<pTjet<<" pt "<<endl;

  ///
  /// distributions vs dphi(charged, jet)
  ///
  for ( int i(1); i<=_nbinsDphi; ++i )
    {
      double x( _xminDphi + (i-1)*_binwidthDphi + _binwidthDphi/2. );
      
      unsigned int iregion(666);
      if      ( TMath::Abs(x) >=   0. && TMath::Abs(x) <   60. ) iregion = 0; /// towards
      else if ( TMath::Abs(x) >=  60. && TMath::Abs(x) <  120. ) iregion = 1; /// transverse
      else if ( TMath::Abs(x) >= 120. && TMath::Abs(x) <  180. ) iregion = 2; /// away
      else
        {
          cout << "[UEActivityHistograms] Error: x = " << x << endl;
          return;
        }

      TH1D* TH1D_dN_vs_dphi  = activity.GetTH1D_dN_vs_dphi(iregion);
      TH1D* TH1D_dpT_vs_dphi = activity.GetTH1D_dpT_vs_dphi(iregion);
      
      /// divide y-entry by binwidth
      /// to get density per degree
      double y(666.);
      y = TH1D_dN_vs_dphi->GetBinContent(i)/(_binwidthDphi*TMath::Pi()/180);
      h_dN_vs_dphi[iHLTbit]->Fill( x, y );
      //   cout<<"contatore"<<i<<endl;
      //cout<<"sono dentro"<<endl;      
      //cout<<y<<" questo e' y"<<endl;
      //cout<<x<<" questo e' x"<<endl;
      //cout<<_binwidthDphi<<" il binning"<<endl;
      //cout<<TH1D_dN_vs_dphi->GetBinContent(i)<<"contenuto"<<endl;
      //int q;
      // if(TH1D_dN_vs_dphi->GetBinContent(i)!=0)cin>>q;
      y = TH1D_dpT_vs_dphi->GetBinContent(i)/(_binwidthDphi*TMath::Pi()/180);
      h_dpT_vs_dphi[iHLTbit]->Fill( x, y );
      //  cout<<_binwidthDphi<<"larghezza del bin"<<endl;
      //cout<<_xminDphi<<"inizio"<<endl;
      //  cout<<_nbinsDphi<<"numero bin"<<endl;

      TH1D* TH1D_dN_vs_dphi_A  = activity.GetTH1D_dN_vs_dphi_A(iregion);
      TH1D* TH1D_dpT_vs_dphi_A = activity.GetTH1D_dpT_vs_dphi_A(iregion);
      
      /// divide y-entry by binwidth
      /// to get density per degree
      y=666.;
      y = TH1D_dN_vs_dphi_A->GetBinContent(i)/(_binwidthDphi*TMath::Pi()/180);
      h_dN_vs_dphi_A[iHLTbit]->Fill( x, y );
      
      y = TH1D_dpT_vs_dphi_A->GetBinContent(i)/(_binwidthDphi*TMath::Pi()/180);
      h_dpT_vs_dphi_A[iHLTbit]->Fill( x, y );
 }
      

  ///
  /// loop on regions
  ///
  double nChg ( 0. );
  double pTsum( 0. );
  for ( unsigned int iregion(0); iregion<3; ++iregion )
    {
      ///
      /// sum up overall activities per unit phi/rad and eta
      ///
      //  nChg  += activity.GetNumParticles(iregion) /(2*TMath::Pi()/3.); old
      // pTsum += activity.GetParticlePtSum(iregion)/(2*TMath::Pi()/3.);
      nChg  += activity.GetNumParticles(iregion)*4;
      pTsum += activity.GetParticlePtSum(iregion)*4;


      ///
      /// densities vs pT(jet) in different regions
      ///
      /// ( divide activity per eta by phi-range (pi/3)
      ///   to get density per eta and phi in radian ) 
      ///
      h_dN_vs_dpTjet [iregion*13+iHLTbit]->Fill( pTjet, activity.GetNumParticles(iregion) /(2*TMath::Pi()/3.) );
      h_dpT_vs_dpTjet[iregion*13+iHLTbit]->Fill( pTjet, activity.GetParticlePtSum(iregion)/(2*TMath::Pi()/3.) );
      //cout<<"controllo del numero di particelle per regione"<<iregion<<endl;
      //     cout<<activity.GetNumParticles(iregion)*4<<endl;
      // cout<<activity.GetParticlePtSum(iregion)*4<<endl;
      //new
       //int pippo;
       // if(activity.GetParticlePtSum(iregion)*4<1.&& iregion==0) cin>>pippo;

      //   h_NChg[iregion*13+iHLTbit]->Fill(activity.GetNumParticles(iregion)*4);

      //  h_pTSChg[iregion*13+iHLTbit]->Fill(activity.GetParticlePtSum(iregion)*4);
     
      TH1D* TH1D_NChg = activity.GetTH1D_NChg(iregion);
      h_NChg[iregion*13+iHLTbit]->Add(TH1D_NChg);
      TH1D* TH1D_pTSChg = activity.GetTH1D_pTSChg(iregion);
      h_pTSChg[iregion*13+iHLTbit]->Add(TH1D_pTSChg);

      if(iregion==1)
	{
	
	  h_dNMax_vs_dpTjet[iHLTbit]->Fill( pTjet,activity.GetNumParticleTraMax()/(TMath::Pi()/3.) );
	  h_dNMin_vs_dpTjet[iHLTbit]->Fill( pTjet,activity.GetNumParticleTraMin()/(TMath::Pi()/3.) );
	
	
	  h_dpTMax_vs_dpTjet[iHLTbit]->Fill( pTjet,activity.GetPtSumParticleTraMax()/(TMath::Pi()/3.) );
	  h_dpTMin_vs_dpTjet[iHLTbit]->Fill( pTjet,activity.GetPtSumParticleTraMin()/(TMath::Pi()/3.) );
	}

      ///
      /// pT-distributions of particles/tracks in different regions
      ///
      TH1D* TH1D_pTChg = activity.GetTH1D_pTChg(iregion);
      h_pTChg1[iregion*13+iHLTbit]->Add(TH1D_pTChg);
      for ( int i(1); i<=_nbinsPtChg; ++i )
	{
	  double x( _xminPtChg + (i-1)*_binwidthPtChg + _binwidthPtChg/2. );
	  double y( TH1D_pTChg->GetBinContent(i) / _binwidthPtChg         );

	  h_pTChg[iregion*13+iHLTbit]->Fill( x, y );
	}

    }

  h_averagePt_vs_nChg[iHLTbit]->Fill( nChg, pTsum/nChg );
  h_pTSumAll[iHLTbit]->Fill(pTsum);
  h_NChgAll[iHLTbit]->Fill(nChg);
}

///
///_______________________________________________________________________
///

///
///_______________________________________________________________________
///
void UEActivityHistograms::fillReco( UEActivity& activity )
{
  ///
  /// histo filler for gen-only analysis
  /// i.e. no trigger bits are available
  ///

  unsigned int iHLTbit( 13 );

  ///
  /// pT-distribution of leading jet
  ///
  double pTjet ( activity.GetLeadingJet().Pt()  );
  double etajet( activity.GetLeadingJet().Eta() );
  h_pTJet [iHLTbit]->Fill( pTjet  );
  h_etaJet[iHLTbit]->Fill( etajet );
  //cout<<"jet nella parte fill"<<endl;
  //cout<<etajet<<" eta "<<pTjet<<" pt "<<endl;

  ///
  /// distributions vs dphi(charged, jet)
  ///
  for ( int i(1); i<=_nbinsDphi; ++i )
    {
      double x( _xminDphi + (i-1)*_binwidthDphi + _binwidthDphi/2. );
      
      unsigned int iregion(666);
      if      ( TMath::Abs(x) >=   0. && TMath::Abs(x) <   60. ) iregion = 0; /// towards
      else if ( TMath::Abs(x) >=  60. && TMath::Abs(x) <  120. ) iregion = 1; /// transverse
      else if ( TMath::Abs(x) >= 120. && TMath::Abs(x) <  180. ) iregion = 2; /// away
      else
        {
          cout << "[UEActivityHistograms] Error: x = " << x << endl;
          return;
        }

      TH1D* TH1D_dN_vs_dphi  = activity.GetTH1D_dN_vs_dphi(iregion);
      TH1D* TH1D_dpT_vs_dphi = activity.GetTH1D_dpT_vs_dphi(iregion);
      
      /// divide y-entry by binwidth
      /// to get density per degree
      double y(666.);
      y = TH1D_dN_vs_dphi->GetBinContent(i)/(_binwidthDphi*TMath::Pi()/180);
      h_dN_vs_dphi[iHLTbit]->Fill( x, y );
      
      y = TH1D_dpT_vs_dphi->GetBinContent(i)/(_binwidthDphi*TMath::Pi()/180);
      h_dpT_vs_dphi[iHLTbit]->Fill( x, y );
      //  cout<<_binwidthDphi<<"larghezza del bin"<<endl;
      //cout<<_xminDphi<<"inizio"<<endl;
      //  cout<<_nbinsDphi<<"numero bin"<<endl;

      TH1D* TH1D_dN_vs_dphi_A  = activity.GetTH1D_dN_vs_dphi_A(iregion);
      TH1D* TH1D_dpT_vs_dphi_A = activity.GetTH1D_dpT_vs_dphi_A(iregion);
      
      /// divide y-entry by binwidth
      /// to get density per degree
      y=666.;
      y = TH1D_dN_vs_dphi_A->GetBinContent(i)/(_binwidthDphi*TMath::Pi()/180);
      h_dN_vs_dphi_A[iHLTbit]->Fill( x, y );
      
      y = TH1D_dpT_vs_dphi_A->GetBinContent(i)/(_binwidthDphi*TMath::Pi()/180);
      h_dpT_vs_dphi_A[iHLTbit]->Fill( x, y );
 }
      

  ///
  /// loop on regions
  ///
  double nChg ( 0. );
  double pTsum( 0. );
  for ( unsigned int iregion(0); iregion<3; ++iregion )
    {
      ///
      /// sum up overall activities per unit phi/rad and eta
      ///
      // nChg  += activity.GetNumParticles(iregion) /(2*TMath::Pi()/3.);
      // pTsum += activity.GetParticlePtSum(iregion)/(2*TMath::Pi()/3.);
      nChg  += activity.GetNumParticles(iregion)*4;
      pTsum += activity.GetParticlePtSum(iregion)*4;

      ///
      /// densities vs pT(jet) in different regions
      ///
      /// ( divide activity per eta by phi-range (pi/3)
      ///   to get density per eta and phi in radian ) 
      ///
      h_dN_vs_dpTjet [iregion*14+iHLTbit]->Fill( pTjet, activity.GetNumParticles(iregion) /(2*TMath::Pi()/3.) );
      h_dpT_vs_dpTjet[iregion*14+iHLTbit]->Fill( pTjet, activity.GetParticlePtSum(iregion)/(2*TMath::Pi()/3.) );
      //cout<<"controllo del numero di particelle per regione"<<iregion<<endl;
      //     cout<<activity.GetNumParticles(iregion)*4<<endl;
      // cout<<activity.GetParticlePtSum(iregion)*4<<endl;
      //new
       //int pippo;
       // if(activity.GetParticlePtSum(iregion)*4<1.&& iregion==0) cin>>pippo;

      //      h_NChg[iregion*14+iHLTbit]->Fill(activity.GetNumParticles(iregion)*4);

      //    h_pTSChg[iregion*14+iHLTbit]->Fill(activity.GetParticlePtSum(iregion)*4);
      TH1D* TH1D_NChg = activity.GetTH1D_NChg(iregion);
      h_NChg[iregion*14+iHLTbit]->Add(TH1D_NChg);
      TH1D* TH1D_pTSChg = activity.GetTH1D_pTSChg(iregion);
      h_pTSChg[iregion*14+iHLTbit]->Add(TH1D_pTSChg);


      if(iregion==1)
	{
	
	  h_dNMax_vs_dpTjet[iHLTbit]->Fill( pTjet,activity.GetNumParticleTraMax()/(TMath::Pi()/3.) );
	  h_dNMin_vs_dpTjet[iHLTbit]->Fill( pTjet,activity.GetNumParticleTraMin()/(TMath::Pi()/3.) );
	
	
	  h_dpTMax_vs_dpTjet[iHLTbit]->Fill( pTjet,activity.GetPtSumParticleTraMax()/(TMath::Pi()/3.) );
	  h_dpTMin_vs_dpTjet[iHLTbit]->Fill( pTjet,activity.GetPtSumParticleTraMin()/(TMath::Pi()/3.) );
	}

      ///
      /// pT-distributions of particles/tracks in different regions
      ///
      TH1D* TH1D_pTChg = activity.GetTH1D_pTChg(iregion);
      h_pTChg1[iregion*14+iHLTbit]->Add(TH1D_pTChg);
      for ( int i(1); i<=_nbinsPtChg; ++i )
	{
	  double x( _xminPtChg + (i-1)*_binwidthPtChg + _binwidthPtChg/2. );
	  double y( TH1D_pTChg->GetBinContent(i) / _binwidthPtChg         );

	  h_pTChg[iregion*14+iHLTbit]->Fill( x, y );
	}

    }

  h_averagePt_vs_nChg[iHLTbit]->Fill( nChg, pTsum/nChg );
  h_pTSumAll[iHLTbit]->Fill(pTsum);
  h_NChgAll[iHLTbit]->Fill(nChg);
}

///
///_______________________________________________________________________
///




void
UEActivityHistograms::fill( UEActivity& activity, TClonesArray& acceptedTriggers )
{
  ///
  /// Histo filler for reco-only analysis
  /// HL trigger bits *are* available
  ///

  ///
  /// 11 HLT bits :
  /// 4 Min-Bias (Pixel, Hcal, Ecal, general), Zero-Bias, 6 Jet (30, 50, 80, 110, 180, 250)
  ///
  unsigned int iHLTbit(0);
  for ( ; iHLTbit<12; ++iHLTbit )
    {
      ///
      /// ask if trigger was accepted
      ///
      bool hltAccept( false );
      unsigned int nAcceptedTriggers( acceptedTriggers.GetSize() );
      for ( unsigned int itrig(0); itrig<nAcceptedTriggers; ++itrig )
	{
	  std::string filterName( acceptedTriggers.At(itrig)->GetName() );      
	  if ( filterName == HLTBitNames[iHLTbit] ) hltAccept = true;
	}
      if ( ! hltAccept ) continue;

      ///
      /// pT-distribution of leading jet
      ///
      double pTjet ( activity.GetLeadingJet().Pt()  );
      double etajet( activity.GetLeadingJet().Eta() );
      h_pTJet [iHLTbit]->Fill( pTjet  );
      h_etaJet[iHLTbit]->Fill( etajet );


      ///
      /// distributions vs dphi(charged, jet)
      ///
      for ( int i(1); i<=_nbinsDphi; ++i )
	{
	  double x( _xminDphi + (i-1)*_binwidthDphi + _binwidthDphi/2. );
	  
	  unsigned int iregion(666);
	  if      ( TMath::Abs(x) >=   0. && TMath::Abs(x) <   60. ) iregion = 0; /// towards
	  else if ( TMath::Abs(x) >=  60. && TMath::Abs(x) <  120. ) iregion = 1; /// transverse
	  else if ( TMath::Abs(x) >= 120. && TMath::Abs(x) <  180. ) iregion = 2; /// away
	  else
	    {
	      cout << "[UEActivityHistograms] Error: x = " << x << endl;
	      return;
	    }
	  
	  TH1D* TH1D_dN_vs_dphi  = activity.GetTH1D_dN_vs_dphi(iregion);
	  TH1D* TH1D_dpT_vs_dphi = activity.GetTH1D_dpT_vs_dphi(iregion);
	  
	  /// divide y-entry by binwidth
	  /// to get density per degree
	  double y(666.);
	  y = TH1D_dN_vs_dphi->GetBinContent(i)/(_binwidthDphi*TMath::Pi()/180);
	  h_dN_vs_dphi[iHLTbit]->Fill( x, y );
	  
	  y = TH1D_dpT_vs_dphi->GetBinContent(i)/(_binwidthDphi*TMath::Pi()/180);
	  h_dpT_vs_dphi[iHLTbit]->Fill( x, y );
	
	  TH1D* TH1D_dN_vs_dphi_A  = activity.GetTH1D_dN_vs_dphi_A(iregion);
	  TH1D* TH1D_dpT_vs_dphi_A = activity.GetTH1D_dpT_vs_dphi_A(iregion);
	  
	  /// divide y-entry by binwidth
	  /// to get density per degree
	  y=666.;
	  y = TH1D_dN_vs_dphi_A->GetBinContent(i)/(_binwidthDphi*TMath::Pi()/180);
	  h_dN_vs_dphi_A[iHLTbit]->Fill( x, y );
	  
	  y = TH1D_dpT_vs_dphi_A->GetBinContent(i)/(_binwidthDphi*TMath::Pi()/180);
	  h_dpT_vs_dphi_A[iHLTbit]->Fill( x, y );

	


	}
      
      
      ///
      /// loop on regions
      ///
      double nChg ( 0. );
      double pTsum( 0. );
      for ( unsigned int iregion(0); iregion<3; ++iregion )
	{
	  ///
	  /// sum up overall activities per unit phi/rad and eta
	  ///
	  //	  nChg  += activity.GetNumParticles(iregion) /(2*TMath::Pi()/3.);
	  // pTsum += activity.GetParticlePtSum(iregion)/(2*TMath::Pi()/3.);
	   nChg  += activity.GetNumParticles(iregion)*4;
	  pTsum += activity.GetParticlePtSum(iregion)*4;
	  
	  ///
	  /// densities vs pT(jet) in different regions
	  ///
	  /// ( divide activity per eta by phi-range (pi/3)
	  ///   to get density per eta and phi in radian ) 
	  ///
	  h_dN_vs_dpTjet [iregion*13+iHLTbit]->Fill( pTjet, activity.GetNumParticles(iregion) /(2*TMath::Pi()/3.) );
	  h_dpT_vs_dpTjet[iregion*13+iHLTbit]->Fill( pTjet, activity.GetParticlePtSum(iregion)/(2*TMath::Pi()/3.) );

//new
      TH1D* TH1D_NChg = activity.GetTH1D_NChg(iregion);
      h_NChg[iregion*13+iHLTbit]->Add(TH1D_NChg);
      TH1D* TH1D_pTSChg = activity.GetTH1D_pTSChg(iregion);
      h_pTSChg[iregion*13+iHLTbit]->Add(TH1D_pTSChg);
	  if(iregion==1)
	{
	  //cout<<iHLTbit<<endl;
	  //cout<<activity.GetNumParticleTraMax()<<endl;
	  //cout<<activity.GetNumParticleTraMin()<<endl;
	  h_dNMax_vs_dpTjet[iHLTbit]->Fill( pTjet,activity.GetNumParticleTraMax()/(TMath::Pi()/3.) );
	  h_dNMin_vs_dpTjet[iHLTbit]->Fill( pTjet,activity.GetNumParticleTraMin()/(TMath::Pi()/3.) );
	
	  
	  //cout<<activity.GetPtSumParticleTraMax()<<endl;
	  //cout<<activity.GetPtSumParticleTraMin()<<endl;
	  h_dpTMax_vs_dpTjet[iHLTbit]->Fill( pTjet,activity.GetPtSumParticleTraMax()/(TMath::Pi()/3.) );
	  h_dpTMin_vs_dpTjet[iHLTbit]->Fill( pTjet,activity.GetPtSumParticleTraMin()/(TMath::Pi()/3.) ); 
	}
	  
	  ///
	  /// pT-distributions of particles/tracks in different regions
	  ///
	  TH1D* TH1D_pTChg = activity.GetTH1D_pTChg(iregion);
	  h_pTChg1[iregion*13+iHLTbit]->Add(TH1D_pTChg);
	  for ( int i(1); i<=_nbinsPtChg; ++i )
	    {
	      double x( _xminPtChg + (i-1)*_binwidthPtChg + _binwidthPtChg/2. );
	      double y( TH1D_pTChg->GetBinContent(i) / _binwidthPtChg         );
	      
	      h_pTChg[iregion*13+iHLTbit]->Fill( x, y );
	    }
	  
	}

      h_averagePt_vs_nChg[iHLTbit]->Fill( nChg, pTsum/nChg );
      h_pTSumAll[iHLTbit]->Fill(pTsum);
      h_NChgAll[iHLTbit]->Fill(nChg);
    }
}

///
///_______________________________________________________________________
///


